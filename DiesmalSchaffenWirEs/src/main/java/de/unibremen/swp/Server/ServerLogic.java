package de.unibremen.swp.Server;

import de.unibremen.swp.Game.Components.Cards.PathCard;
import de.unibremen.swp.Game.Components.Cards.Type.PathType;
import de.unibremen.swp.Game.Components.Field;
import de.unibremen.swp.Game.Components.Player;
import org.javatuples.Triplet;
import java.util.*;

/**
 * Gameserver logic
 * Defines necessary methods to process inbound
 * GameClient messages
 *
 * @author Mut Daniel, Zimmermann Henning, Drescher Lennart
 */

public class ServerLogic {

    private Field field;

    /**
     * Construct ServerLogic
     * @param field Field object
     */
    public ServerLogic(final Field field) {
        this.field = field;
    }

    /**
     * Retrieve local field
     * @return Local field
     */
    public Field getField() {
        return field;
    }

    /**
     * Retrieves a GameClient's Player object given its client id
     * @param id The GameClient id whose player is to be retrieved
     * @return The GameClient's player
     */
    public Player getPlayerBySenderId(final String id) {
        for(Player player : field.getPlayerList()) {
            if(player.getId().equals(id)) {
                return player;
            }
        }
        throw new IllegalArgumentException("No such player found!");
    }


    /**
     * For debugging purposes
     * Padding binary string with zeros to match length 4
     * @param bin Integer to be converted to binary
     * @return Padded 4-digit binary string
     */
    public String pad(int bin) {
        return String.format("%4s", Integer.toBinaryString(bin)).replace(' ', '0');
    }

    /**
     * Generates a bitflag representing possible paths from the card passed as a parameter
     * Bitflags are generated by setting or unsetting 4 bits, each representing a cardinal direction (-y, +x, +y, -x)
     * e.g.:
     *       -y ( = 1)     rotation = 3
     *       ___
     *      |   |
     * -x   |   |      +x ( = 1)
     *      |   _______
     *      |_________|
     *       +y
     * resulting in a flag of (0b0110 >> 3) = 0b1100 for an angled path in rotation 3.
     *
     * @param card The PathCard whose neighborhood flag is to be calculated
     * @return A neighborhood bitflag
     */
    public int generateFlag(final PathCard card) {
        int flag = -1;
        int delta = card.getRotation();
        switch(String.valueOf(card.getPathType())) {
            case PathType.ANGLE:
                flag = circularRight(0b0110, delta);
                break;
            case PathType.STRAIGHT:
                flag = circularRight(0b0101, delta);
                break;
            case PathType.JUNCTION:
                flag = circularRight(0b0111, delta);
                break;
        }
        return flag;
    }

    /**
     * Shifts a given flag by a given delta while prepending bits that
     * would've been lost during standard bitshifts.
     * Shifting 0b0110 by a delta of 3 would result in 0b1100 rather than 0b0000
     * @param flag Four bit long bitflag to be shifted right by delta
     * @param delta Shift delta
     * @return Bitflag shifted by delta
     */
    public int circularRight(final int flag, final int delta) {
        final int bits = 4;
        final int mask = (1 << bits) - 1;

        return mask & ((flag << (bits - delta)) | (flag >>> delta));
    }

    /**
     * Compiles a list of directly adjacent PathCards that are reachable
     * from a given origin card.
     * @param card PathCard whose neighborhood is to be determined
     * @return A list of directly adjacent and reachable PathCards
     */

    public ArrayList<PathCard> connections(final PathCard card) {
        int[] index = field.getIndices(card);
        char nY = '0', pX = '0', pY = '0', nX = '0';
        ArrayList<PathCard> connectedNeighbors = new ArrayList<>();
        int centerFlag = generateFlag(card);

        if(!((index[1] - 1) < 0)) {
            PathCard top = field.getPathCard(index[0], index[1] - 1);
            int topFlag = circularRight(generateFlag(top), 2);
            nY = pad(centerFlag & topFlag).charAt(0);
            if(nY == '1'){
                connectedNeighbors.add(top);
            }
        }

        if(!((index[0] + 1) > 6)) {
            PathCard right = field.getPathCard(index[0] + 1, index[1]);
            int rightFlag = circularRight(generateFlag(right), 2);
            pX = pad(centerFlag & rightFlag).charAt(1);
            if(pX == '1'){
                connectedNeighbors.add(right);
            }
        }

        if(!((index[1] + 1) > 6)) {
            PathCard bottom = field.getPathCard(index[0], index[1] + 1);
            int bottomFlag = circularRight(generateFlag(bottom), 2);
            pY = pad(centerFlag & bottomFlag).charAt(2);
            if(pY == '1'){
                connectedNeighbors.add(bottom);
            }
        }

        if(!((index[0] - 1) < 0)) {
            PathCard left = field.getPathCard(index[0] - 1, index[1]);
            int leftFlag = circularRight(generateFlag(left), 2);
            nX = pad(centerFlag & leftFlag).charAt(3);
            if(nX == '1'){
                connectedNeighbors.add(left);
            }
        }

        return connectedNeighbors;
    }

    /**
     * Calculates all PathCards reachable from a given origin PathCard
     * @param startCard The search origin
     * @return All PathCards directly reachable from the origin
     */
    public ArrayList<PathCard> possiblePaths(PathCard startCard){
        Queue<PathCard> queue = new LinkedList<>();
        queue.add(startCard);

        ArrayList<PathCard> possiblePaths = new ArrayList<>();
        possiblePaths.add(startCard);

        while(queue.size() > 0){
            ArrayList<PathCard> neighbors = connections(queue.poll());
            while (neighbors.size() > 0){
                if(!possiblePaths.contains(neighbors.get(0))){
                    possiblePaths.add(neighbors.get(0));
                    queue.add(neighbors.get(0));
                }
                neighbors.remove(0);
            }
        }
        return possiblePaths;
    }

    /**
     * Validates a given player's chosen figure move
     * @param or The player's figure origin
     * @param des The selected destination
     * @return Whether or not a direct path to the destination exists
     */
    public boolean validateMove(final int[] or, final int[] des) {
        PathCard origin = field.getPathCard(or[0],or[1]);
        PathCard destination = field.getPathCard(des[0],des[1]);

        ArrayList<PathCard> paths = possiblePaths(origin);
        if(paths.contains(destination)){
            System.out.println("Move OK");
            return true;
        }
        System.out.println("Move NOT OK");
        return false;
    }

    /**
     * Test whether a PathCard can be inserted from the specified direction
     * at the specified x (relevant for column insertion) and y
     * (relevant for row insertion) coordinates
     *
     * forbiddenPathMove is set after insertion to the opposite action
     * If insertion happens from LEFT at y = 3, forbiddenPathMove
     * will be set to RIGHT at y = 3
     *
     * @param move Triplet specifying the desired insertion action
     * @return Whether or not a PathCard is allowed to be inserted
     */
    public boolean validatePathMove(Triplet<String, Integer, Integer> move){
        if(Field.getForbiddenPathMove().equals(move)){
            return false;
        }
        return true;
    }
}
